╔════════════════════════════════════════════════════════════════╗
║              CODE OPTIMIZATION ANALYSIS & PLAN                 ║
╚════════════════════════════════════════════════════════════════╝

═══════════════════════════════════════════════════════════════════
                   CURRENT CODE ANALYSIS
═══════════════════════════════════════════════════════════════════

Current File Size: ~1688 lines
Functions: ~40+ functions
Memory Usage: Moderate with some inefficiencies

═══════════════════════════════════════════════════════════════════
                   OPTIMIZATION AREAS FOUND
═══════════════════════════════════════════════════════════════════

1. DUPLICATE FILE PATH HANDLING
   ├─ Problem: Multiple functions add "/" to filenames
   ├─ Current Code:
   │  if (!filename.startsWith("/")) {
   │    filename = "/" + filename;
   │  }
   ├─ Found in: READ, DEL commands (2 places)
   └─ Solution: Create single helper function normalizeFilePath()

2. DUPLICATE STRING OPERATIONS
   ├─ Problem: Case conversion repeated in searchFiles()
   ├─ Current Code:
   │  String filenameUpper = filename;
   │  filenameUpper.toUpperCase();
   │  String patternUpper = String(searchPattern);
   │  patternUpper.toUpperCase();
   ├─ Issue: Creates temporary strings, allocates memory
   └─ Solution: Use case-insensitive comparison with toCharArray()

3. DUPLICATE SERIAL FORMATTING
   ├─ Problem: Same divider lines printed in 4 functions
   ├─ Examples:
   │  Serial.println("─────────────────────────────────────────────");
   │  Serial.println("─────┼──────────────────────────────────┼──────────────");
   │  Serial.println("─────┴──────────────────────────────────┴──────────────");
   └─ Solution: Create printDivider(), printHeader() functions

4. DUPLICATE DISPLAY FORMATTING
   ├─ Problem: Same text sizing/centering in drawMainScreen()
   ├─ Current Code Duplicates:
   │  display.setTextSize(1);
   │  display.setTextColor(SSD1306_WHITE);
   │  (repeated 6+ times in same function)
   ├─ Count Centering Logic:
   │  display.getTextBounds(countStr, 0, 0, &x1, &y1, &w, &h);
   │  int xPos = (SCREEN_WIDTH - w) / 2;
   │  (duplicated in active and stopped sections)
   └─ Solution: Create displayText(), centerText() helpers

5. REDUNDANT VARIABLE INITIALIZATION
   ├─ Problem: x1, y1, w, h declared in multiple scopes
   ├─ In drawMainScreen():
   │  int16_t x1, y1;
   │  uint16_t w, h;
   │  (declared twice in same function)
   └─ Solution: Declare once at function start

6. INEFFICIENT STRING CONCATENATION
   ├─ Problem: Using String class creates temporary objects
   ├─ Examples:
   │  filename = "/" + filename;  // Creates temporary string
   │  String timeStr = "Start: " + time;
   └─ Solution: Use char arrays or snprintf()

7. REPEATED FILE EXISTENCE CHECKS
   ├─ Problem: SD.exists() called multiple times
   ├─ In deleteFile():
   │  if (!SD.exists(filename))  // Check 1
   │  if (SD.exists(filename.c_str()))  // Check 2
   └─ Solution: Call once, store result

8. INEFFICIENT EEPROM OPERATIONS
   ├─ Problem: EEPROM.begin() called per function, not batched
   ├─ Functions:
   │  saveSettingsToEEPROM() - calls begin()
   │  loadSettingsFromEEPROM() - calls begin()
   ├─ Issue: Each call initializes EEPROM system
   └─ Solution: Keep EEPROM in initialized state during setup

9. SERIAL OUTPUT OVERHEAD
   ├─ Problem: Multiple Serial.print() calls instead of println()
   ├─ Example in startProduction():
   │  Serial.print("Start Time: ");
   │  Serial.print(productionStartTime.year()); // 8 print calls
   │  ...
   └─ Solution: Use snprintf() with single println()

10. REDUNDANT INTERRUPT DEBOUNCE CHECK
    ├─ Problem: handleLatchingButton() recreates latch logic
    ├─ Different from handleInterrupt() unnecessarily
    └─ Solution: Could use common debounce pattern

═══════════════════════════════════════════════════════════════════
                   OPTIMIZATION PRIORITIES
═══════════════════════════════════════════════════════════════════

HIGH PRIORITY (Most Impact):
  1. Create helper functions for file path normalization
  2. Consolidate display formatting code
  3. Reduce String class usage
  4. Batch EEPROM operations

MEDIUM PRIORITY (Noticeable Improvement):
  5. Consolidate serial formatting (dividers, headers)
  6. Reduce serial output overhead
  7. Single-pass variable declarations

LOW PRIORITY (Marginal Gains):
  8. Redundant variable checks
  9. Refactor similar interrupt handlers
  10. Minor code restructuring

═══════════════════════════════════════════════════════════════════
                   ESTIMATED IMPROVEMENTS
═══════════════════════════════════════════════════════════════════

Code Size Reduction: 8-12%
  └─ Remove 130-200 lines of duplicated code

Memory Usage: 10-15% reduction
  └─ Fewer temporary String objects

Runtime Performance: 5-8% faster
  └─ Fewer string allocations, optimized functions

Maintainability: Significantly improved
  └─ Single source of truth for common operations

═══════════════════════════════════════════════════════════════════
                   OPTIMIZATION IMPLEMENTATION
═══════════════════════════════════════════════════════════════════

STEP 1: Create Helper Functions (New Section)
├─ normalizeFilePath(const char* filename) → const char*
├─ printDivider(int type) → void
├─ printHeader(const char* title) → void
├─ displayText(int size, int x, int y, const char* text) → void
├─ centerText(int size, int y, const char* text) → void
└─ formatTime(char* buffer, DateTime dt, bool includeSeconds) → void

STEP 2: Refactor File Functions
├─ updateListAllFiles() - use printDivider()
├─ updateReadFile() - use printHeader()
├─ updateSearchFiles() - use printDivider()
├─ updateDeleteFile() - consolidate checks
└─ updateReadProductionFiles() - use printHeader()

STEP 3: Optimize Display Functions
├─ Consolidate drawMainScreen() - single text setup section
├─ Move x1, y1, w, h to function start
├─ Create helper for count display
└─ Create helper for status display

STEP 4: Streamline Serial Output
├─ Use snprintf() for time formatting
├─ Batch Serial.print() calls
└─ Reduce number of println() calls

STEP 5: Optimize EEPROM Usage
├─ Remove unnecessary begin/end cycles
└─ Batch multiple reads

═══════════════════════════════════════════════════════════════════
                   CODE METRICS BEFORE
═══════════════════════════════════════════════════════════════════

Total Lines: 1688
Functions: 42
Duplicate Code Sections: 12
String Allocations per Loop: 3-5
Serial.print() per operation: 5-15
Memory Peak Usage: ~15KB

═══════════════════════════════════════════════════════════════════
                   CODE METRICS AFTER OPTIMIZATION
═══════════════════════════════════════════════════════════════════

Target Total Lines: 1500-1550 (10-12% reduction)
Target Functions: 48 (added 6 helpers)
Target Duplicate Sections: 0-1 (consolidated)
Target String Allocations: 1-2 per loop
Target Serial.print() per operation: 1-3
Target Memory Peak Usage: ~13KB

═══════════════════════════════════════════════════════════════════
                   SPECIFIC OPTIMIZATIONS
═══════════════════════════════════════════════════════════════════

OPTIMIZATION 1: File Path Normalization
────────────────────────────────────────

BEFORE:
  if (input.startsWith("READ,")) {
    String filename = input.substring(5);
    if (!filename.startsWith("/")) {
      filename = "/" + filename;
    }
    readFile(filename.c_str());
  }
  
  if (input.startsWith("DEL,")) {
    String filename = input.substring(4);
    if (!filename.startsWith("/")) {
      filename = "/" + filename;
    }
    deleteFile(filename.c_str());
  }

AFTER:
  if (input.startsWith("READ,")) {
    String filename = normalizeFilePath(input.substring(5).c_str());
    readFile(filename.c_str());
  }

CODE SAVED: ~8 lines per occurrence × 2 = 16 lines

────────────────────────────────────────

OPTIMIZATION 2: Serial Dividers
────────────────────────────────────────

BEFORE (in 4 functions):
  Serial.println("─────┴──────────────────────────────────┴──────────────");
  Serial.println("─────────────────────────────────────────────");
  (repeated throughout)

AFTER (call helper):
  printDivider(DIVIDER_TABLE_BOTTOM);  // Single line

CODE SAVED: ~4 lines per function × 4 functions = 16 lines

────────────────────────────────────────

OPTIMIZATION 3: Display Text Centering
────────────────────────────────────────

BEFORE (in drawMainScreen):
  int16_t x1, y1;
  uint16_t w, h;
  display.getTextBounds(countStr, 0, 0, &x1, &y1, &w, &h);
  int xPos = (SCREEN_WIDTH - w) / 2;
  display.setCursor(xPos, 20);
  display.println(countStr);
  
  // ... (repeated again for STOPPED section)
  int16_t x1, y1;
  uint16_t w, h;
  display.getTextBounds(countStr, 0, 0, &x1, &y1, &w, &h);
  int xPos = (SCREEN_WIDTH - w) / 2;
  display.setCursor(xPos, 20);
  display.println(countStr);

AFTER:
  centerText(3, 20, countStr);  // Called twice

CODE SAVED: ~10 lines

────────────────────────────────────────

OPTIMIZATION 4: Time Formatting
────────────────────────────────────────

BEFORE (in startProduction):
  Serial.print("Start Time: ");
  Serial.print(productionStartTime.year()); Serial.print("-");
  Serial.print(productionStartTime.month()); Serial.print("-");
  Serial.print(productionStartTime.day()); Serial.print(" ");
  Serial.print(productionStartTime.hour()); Serial.print(":");
  Serial.print(productionStartTime.minute()); Serial.print(":");
  Serial.println(productionStartTime.second());

AFTER:
  char timeStr[30];
  formatTime(timeStr, productionStartTime, true);
  Serial.print("Start Time: ");
  Serial.println(timeStr);

CODE SAVED: ~6 lines, 50% fewer Serial.print() calls

════════════════════════════════════════════════════════════════════
